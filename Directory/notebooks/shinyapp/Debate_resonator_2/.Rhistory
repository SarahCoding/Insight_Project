)
}
})
}
shinyApp(ui, server)
outline <- quakes[chull(quakes$long, quakes$lat),]
map <- leaflet(quakes) %>%
# Base groups
addTiles(group = "OSM (default)") %>%
addProviderTiles(providers$Stamen.Toner, group = "Toner") %>%
addProviderTiles(providers$Stamen.TonerLite, group = "Toner Lite") %>%
# Overlay groups
addCircles(~long, ~lat, ~10^mag/5, stroke = F, group = "Quakes") %>%
addPolygons(data = outline, lng = ~long, lat = ~lat,
fill = F, weight = 2, color = "#FFFFCC", group = "Outline") %>%
# Layers control
addLayersControl(
baseGroups = c("OSM (default)", "Toner", "Toner Lite"),
overlayGroups = c("Quakes", "Outline"),
options = layersControlOptions(collapsed = FALSE)
)
map
score <-rank(as.data.frame(subset(data_scores$norm_cos, data_scores$Candidate=="Biden")))
rm(main_data)
score
score <-rank(as.data.frame(subset(data_scores$norm_cos, data_scores$Candidate=="Biden")))
outline <- quakes[chull(quakes$long, quakes$lat),]
map <- leaflet(data_full) %>%
# Base groups
addTiles(group = "Joe Biden") %>%
addProviderTiles(score, group = "Similarity Score") %>%
addProviderTiles(providers$Stamen.TonerLite, group = "Toner Lite") %>%
# Overlay groups
addCircles(~lng, ~lat, ~10^mag/5, stroke = F, group = "Quakes") %>%
addCircles(~lng, ~lat, ~10^mag/5, stroke = F, group = "Quakes"m color="red") %>%
# Layers control
addLayersControl(
baseGroups = c("OSM (default)", "Toner", "Toner Lite"),
overlayGroups = c("Quakes", "Outline"),
options = layersControlOptions(collapsed = FALSE)
)
map
outline <- quakes[chull(quakes$long, quakes$lat),]
map <- leaflet(quakes) %>%
# Base groups
addTiles(group = "OSM (default)") %>%
# Overlay groups
addCircles(~long, ~lat, ~10^mag/5, stroke = F, group = "Quakes") %>%
addPolygons(data = outline, lng = ~long, lat = ~lat,
fill = F, weight = 2, color = "#FFFFCC", group = "Outline") %>%
# Layers control
addLayersControl
overlayGroups = c("Quakes", "Outline"),
options = layersControlOptions(collapsed = FALSE)
)
map
score <-rank(as.data.frame(subset(data_scores$norm_cos, data_scores$Candidate=="Biden")))
outline <- quakes[chull(quakes$long, quakes$lat),]
map <- leaflet(quakes) %>%
# Base groups
addTiles(group = "OSM (default)") %>
# Overlay groups
addCircles(~long, ~lat, ~10^mag/5, stroke = F, group = "Quakes") %>%
addPolygons(data = outline, lng = ~long, lat = ~lat,
fill = F, weight = 2, color = "#FFFFCC", group = "Outline") %>%
# Layers control
addLayersControl(
baseGroups = c("OSM (default)"),
overlayGroups = c("Quakes", "Outline"),
options = layersControlOptions(collapsed = FALSE)
)
map
l <- leaflet() %>% addTiles()
names(data_full) %>%
purrr::walk( function(df) {
l <<- l %>%
addMarkers(data=data_full[[df]],
lng=~lng, lat=~lat,
label=~as.character(cos),
popup=~as.character(cos),
group = df,
clusterOptions = markerClusterOptions(removeOutsideVisibleBounds = F),
labelOptions = labelOptions(noHide = F,
direction = 'auto'))
})
l %>%
addLayersControl(
overlayGroups = names(data_full),
options = layersControlOptions(collapsed = FALSE)
)
data=data_full[[df]]
names(data_full) %>%
purrr::walk( function(df) {
l <<- l %>%
addMarkers(data=data_full[[df]],
lng=~lng, lat=~lat,
label=~as.character(cos),
popup=~as.character(cos),
group = data_full$Candidate,
clusterOptions = markerClusterOptions(removeOutsideVisibleBounds = F),
labelOptions = labelOptions(noHide = F,
direction = 'auto'))
})
l %>%
addLayersControl(
overlayGroups = names(data_full),
options = layersControlOptions(collapsed = FALSE)
)
names(data_full$Candidate)
names(data_full) %>%
purrr::walk( function(df) {
l <<- l %>%
addMarkers(data=data_full[[df]],
lng=~lng, lat=~lat,
label=~as.character(cos),
popup=~as.character(cos),
group = df,
clusterOptions = markerClusterOptions(removeOutsideVisibleBounds = F),
labelOptions = labelOptions(noHide = F,
direction = 'auto'))
})
l %>%
addLayersControl(
overlayGroups = unique(data_full$Candidate),
options = layersControlOptions(collapsed = FALSE)
)
ui <- bootstrapPage(
tags$style(type = "text/css", "html, body {width:100%;height:100%}"),
leafletOutput("map", width = "100%", height = "100%"),
absolutePanel(top = 10, right = 10,
sliderInput("range", "Magnitudes", min(data_full$norm_cos), max(data_full$norm_cos),
value = range(data_full$norm_cos), step = 0.1
),
selectInput("candidates", "Candidates",c( "Joe Biden"="Biden",
"Pete Buttigieg"="Buttigieg",
"Amy Klobuchar"="Klobuchar",
"Bernie Sanders"="Sanders",
"Tom Steyer"="Steyer",
"Elizabeth Warren"="Warren",
"Andrew Yang"="Yang"))
),
checkboxInput("legend", "Show legend", TRUE)
)
library(shiny)
library(leaflet)
library(RColorBrewer)
#https://rstudio.github.io/leaflet/shiny.html
library(shiny)
library(leaflet)
library(RColorBrewer)
ui <- bootstrapPage(
tags$style(type = "text/css", "html, body {width:100%;height:100%}"),
leafletOutput("map", width = "100%", height = "100%"),
absolutePanel(top = 10, right = 10,
selectInput("candidates", "Candidates",c( "Joe Biden"="Biden",
"Pete Buttigieg"="Buttigieg",
"Amy Klobuchar"="Klobuchar",
"Bernie Sanders"="Sanders",
"Tom Steyer"="Steyer",
"Elizabeth Warren"="Warren",
"Andrew Yang"="Yang"))
),
checkboxInput("legend", "Show legend", TRUE)
)
server <- function(input, output, session) {
# Reactive expression for the data subsetted to what the user selected
filteredData <- reactive({
data_full[data_full$norm_cos >= input$range[1] & data_full$norm_cos <= input$range[2],]
})
# This reactive expression represents the palette function,
# which changes as the user makes selections in UI.
colorpal <- reactive({
colorNumeric(input$colors, data_full$norm_cos)
})
output$map <- renderLeaflet({
# Use leaflet() here, and only include aspects of the map that
# won't need to change dynamically (at least, not unless the
# entire map is being torn down and recreated).
leaflet(data_full) %>% addTiles() %>%
fitBounds(~min(lng), ~min(lat), ~max(lng), ~max(lat))
})
# Incremental changes to the map (in this case, replacing the
# circles when a new color is chosen) should be performed in
# an observer. Each independent set of things that can change
# should be managed in its own observer.
observe({
pal <- colorpal()
leafletProxy("map", data = data_full()) %>%
clearShapes() %>%
addCircles(radius = ~10^norm_cos/10, weight = 1, color = "#777777",
fillColor = ~pal(norm_cos), fillOpacity = 0.7, popup = ~paste(norm_cos)
)
})
}
shinyApp(ui, server)
library(shiny)
library(leaflet)
library(RColorBrewer)
#https://rstudio.github.io/leaflet/shiny.html
library(shiny)
library(leaflet)
library(RColorBrewer)
ui <- bootstrapPage(
tags$style(type = "text/css", "html, body {width:100%;height:100%}"),
leafletOutput("map", width = "100%", height = "100%"),
absolutePanel(top = 10, right = 10,
selectInput("candidate", "Candidates",c( "Joe Biden"="Biden",
"Pete Buttigieg"="Buttigieg",
"Amy Klobuchar"="Klobuchar",
"Bernie Sanders"="Sanders",
"Tom Steyer"="Steyer",
"Elizabeth Warren"="Warren",
"Andrew Yang"="Yang"))
),
checkboxInput("legend", "Show legend", TRUE)
)
server <- function(input, output, session) {
output$map <- renderLeaflet({
# Use leaflet() here, and only include aspects of the map that
# won't need to change dynamically (at least, not unless the
# entire map is being torn down and recreated).
leaflet(data_full) %>% addTiles() %>%
fitBounds(~min(lng), ~min(lat), ~max(lng), ~max(lat))
})
# Incremental changes to the map (in this case, replacing the
# circles when a new color is chosen) should be performed in
# an observer. Each independent set of things that can change
# should be managed in its own observer.
observe({
pal <- colorpal()
leafletProxy("map", data = data_full()) %>%
clearShapes() %>%
addCircles(radius = ~10^norm_cos/10, weight = 1, color = "#777777",
fillColor = ~pal(norm_cos), fillOpacity = 0.7, popup = ~paste(norm_cos)
)
})
}
shinyApp(ui, server)
library(shiny)
library(leaflet)
library(RColorBrewer)
#https://rstudio.github.io/leaflet/shiny.html
library(shiny)
library(leaflet)
library(RColorBrewer)
ui <- bootstrapPage(
tags$style(type = "text/css", "html, body {width:100%;height:100%}"),
leafletOutput("map", width = "100%", height = "100%"),
absolutePanel(top = 10, right = 10,
selectInput("candidate", "Candidates",c( "Joe Biden"="Biden",
"Pete Buttigieg"="Buttigieg",
"Amy Klobuchar"="Klobuchar",
"Bernie Sanders"="Sanders",
"Tom Steyer"="Steyer",
"Elizabeth Warren"="Warren",
"Andrew Yang"="Yang"))
),
checkboxInput("legend", "Show legend", TRUE)
)
server <- function(input, output, session) {
output$map <- renderLeaflet({
# Use leaflet() here, and only include aspects of the map that
# won't need to change dynamically (at least, not unless the
# entire map is being torn down and recreated).
leaflet(data_full) %>% addTiles() %>%
fitBounds(~min(lng), ~min(lat), ~max(lng), ~max(lat))
})
# Incremental changes to the map (in this case, replacing the
# circles when a new color is chosen) should be performed in
# an observer. Each independent set of things that can change
# should be managed in its own observer.
observe({
leafletProxy("map", data = data_full()) %>%
clearShapes() %>%
addCircles(radius = ~10^norm_cos/10, weight = 1, color = "#777777",
fillOpacity = 0.7, popup = ~paste(norm_cos)
)
})
}
shinyApp(ui, server)
library(shiny)
library(leaflet)
library(RColorBrewer)
#https://rstudio.github.io/leaflet/shiny.html
library(shiny)
library(leaflet)
library(RColorBrewer)
ui <- bootstrapPage(
tags$style(type = "text/css", "html, body {width:100%;height:100%}"),
leafletOutput("map", width = "100%", height = "100%"),
absolutePanel(top = 10, right = 10,
selectInput("candidate", "Candidates",c( "Joe Biden"="Biden",
"Pete Buttigieg"="Buttigieg",
"Amy Klobuchar"="Klobuchar",
"Bernie Sanders"="Sanders",
"Tom Steyer"="Steyer",
"Elizabeth Warren"="Warren",
"Andrew Yang"="Yang"))
),
checkboxInput("legend", "Show legend", TRUE)
)
server <- function(input, output, session) {
output$map <- renderLeaflet({
# Use leaflet() here, and only include aspects of the map that
# won't need to change dynamically (at least, not unless the
# entire map is being torn down and recreated).
leaflet(data_full) %>% addTiles() %>%
fitBounds(~min(lng), ~min(lat), ~max(lng), ~max(lat))
})
# Incremental changes to the map (in this case, replacing the
# circles when a new color is chosen) should be performed in
# an observer. Each independent set of things that can change
# should be managed in its own observer.
observe({
leafletProxy("map", data = data_full) %>%
clearShapes() %>%
addCircles(radius = ~10^norm_cos/10, weight = 1, color = "#777777",
fillOpacity = 0.7, popup = ~paste(norm_cos)
)
})
}
shinyApp(ui, server)
#States=as.data.frame(unique(data_scores$State))
lng2=as.data.frame(unique(data_scores$lng))
lat2=as.data.frame(unique(data_scores$lat))
##webapp
ui <-fluidPage(
titlePanel("Debate Reactor"),
sidebarLayout(
sidebarPanel(
helpText("Create maps ranking twitter reaction by state following debates."),
selectInput("candidate",
label = "Choose a candidate to display",
choices = c( "Joe Biden"="Biden",
"Pete Buttigieg"="Buttigieg",
"Amy Klobuchar"="Klobuchar",
"Bernie Sanders"="Sanders",
"Tom Steyer"="Steyer",
"Elizabeth Warren"="Warren",
"Andrew Yang"="Yang"),
selected = "Candidate"),
dateInput("date", label = h3("Date of debate"), value = "2019-12-20")),
hr()),
mainPanel(
textOutput("candidate_selected"),
leafletOutput("map"),
p()
)
)
#barplot(rank(as.data.frame(subset(data_full$cos, data_full$Candidate=="Biden"))))
server <- function(input, output, session) {
output$candidate_selected <- renderText({
paste("Twitter engagement for", input$candidate, "for debate on",
input$date, "Topics include RACISM and GUN VIOLENCE.")
})
output$map <- renderLeaflet({
score <- rank(as.data.frame(subset(data_scores$norm_cos, data_scores$Candidate==input$candidate)))
#score <-rank(as.data.frame(subset(data_scores$norm_cos, data_scores$Candidate=="Biden")))
df<-cbind(score, lng2, lat2)
colnames(df)=c( "score", "lng", "lat")
leaflet(df) %>% addTiles() %>%
addCircles(lng = ~lng, lat = ~lat, weight = 1,
radius = ~score * 30000, popup = paste( "Debate resonated #",data=rank(-(subset(data_scores$norm_cos,
data_scores$Candidate==input$candidate)), ties.method = "last"),
"among 11 swing states" ))%%
leaflet(data_full,width = 400, height = 400 ) %>% addTiles()
addCircles(color='red', lng = ~lng, lat = ~lat, weight = 1,
radius = ~length((subset(data_full$cos,data_full$Candidate==input$candidate)))*200, popup = paste( data=length((subset(data_full$cos,data_full$Candidate==input$candidate))),
"tweets tweeted" ))%>%
#addCircles(color='red', lng = ~lng, lat = ~lat, weight = 1,
#          radius = ~length((subset(data_full$cos,data_full$Candidate=="Biden")))*20, popup = paste( data=length((subset(data_full$cos,data_full$Candidate==input$candidate))),
#                                                                                                           "tweets tweeted" ))%>%
addLayersControl(
overlayGroups = c("Similarity Rank", "Number of Tweets"),
options = layersControlOptions(collapsed = FALSE)
)
})
}
shinyApp(ui, server)
##webapp
ui <-fluidPage(
titlePanel("Debate Reactor"),
sidebarLayout(
sidebarPanel(
helpText("Create maps ranking twitter reaction by state following debates."),
selectInput("candidate",
label = "Choose a candidate to display",
choices = c( "Joe Biden"="Biden",
"Pete Buttigieg"="Buttigieg",
"Amy Klobuchar"="Klobuchar",
"Bernie Sanders"="Sanders",
"Tom Steyer"="Steyer",
"Elizabeth Warren"="Warren",
"Andrew Yang"="Yang"),
selected = "Candidate"),
dateInput("date", label = h3("Date of debate"), value = "2019-12-20")),
hr()),
mainPanel(
textOutput("candidate_selected"),
leafletOutput("map"),
p()
)
)
server <- function(input, output, session) {
output$candidate_selected <- renderText({
paste("Twitter engagement for", input$candidate, "for debate on",
input$date, "Topics include RACISM and GUN VIOLENCE.")
})
output$map <- renderLeaflet({
score <- rank(as.data.frame(subset(dataclean$norm_cos, dataclean$Candidate==input$candidate)))
#score <-rank(as.data.frame(subset(dataclean$norm_cos, dataclean$Candidate=="Biden")))
df<-cbind(score, lng2, lat2)
colnames(df)=c( "score", "lng", "lat")
leaflet(df,width = 400, height = 400 ) %>% addTiles() %>%
addCircles(lng = ~lng, lat = ~lat, weight = 1,
radius = ~score * 30000, popup = paste( "Debate resonated #",data=rank(-(subset(dataclean$norm_cos,
dataclean$Candidate==input$candidate)), ties.method = "last"),
"among 11 swing states" )
)
})
}
shinyApp(ui, server)
#Debate_20191220 resonatory deploy
library(dplyr)
library(leaflet)
library(maps)
library(Rcpp)
library(rsconnect)
library(shiny)
library(tidyr)
#rsconnect::setAccountInfo(name='sarahcoding', token='0FBD24670D53516D9A94DA892DEF8FBC', secret='zVjk5Bc2xNliBrOialxeh/XENbgIjTo8nVvwUOtM')
#rsconnect::deployApp('C:/Users/sarah/Dropbox/Insight_fellowship/Project/Directory/notebooks/shinyapp/Debate_resonator/Debate_twitter_cos_app_withmissing.R')
setwd("C:/Users/sarah/Dropbox/Insight_fellowship/Project/Directory/notebooks/shinyapp/Debate_resonator_2/")
#data pull and clean
tweets_Debate_20191220=read.csv("Tweets_Debate_20191220.csv")
missing=as.data.frame(read.csv("missing_cleaned_values_debate_20191220.csv")[1:3])
main_data=tweets_Debate_20191220[,c("State", "Candidate", "cos")]
data_full=rbind(missing, main_data)
Candidate2=(gsub( "_tw", "", as.character(data_full$Candidate)))#one time fix
data_full$Candidate <- Candidate2 #one time fix
#add geographical information for leaflet below
#Col Flo Mic Min Nev New Nor Ohi Pen Vir Wis
data_full$lng[data_full$State=="Col"]=-105.358887
data_full$lat[data_full$State=="Col"]=39.113014
data_full$lng[data_full$State=="Flo"]=-81.760254
data_full$lat[data_full$State=="Flo"]=27.994402
data_full$lng[data_full$State=="Mic"]=-84.506836
data_full$lat[data_full$State=="Mic"]=44.182205
data_full$lng[data_full$State=="Min"]=-94.636230
data_full$lat[data_full$State=="Min"]=46.392410
data_full$lng[data_full$State=="Nev"]=-117.224121
data_full$lat[data_full$State=="Nev"]=39.876019
data_full$lng[data_full$State=="New"]=-71.500000
data_full$lat[data_full$State=="New"]=44.000000
data_full$lng[data_full$State=="Nor"]=-80.793457
data_full$lat[data_full$State=="Nor"]=35.782169
data_full$lng[data_full$State=="Ohi"]=-82.9071
data_full$lat[data_full$State=="Ohi"]=40.4173
data_full$lng[data_full$State=="Pen"]=-77.1945
data_full$lat[data_full$State=="Pen"]=41.2033
data_full$lng[data_full$State=="Vir"]=-78.6569
data_full$lat[data_full$State=="Vir"]=37.4316
data_full$lng[data_full$State=="Wis"]=-89.500000
data_full$lat[data_full$State=="Wis"]=44.500000
data_scores=as.data.frame(summarise_at(group_by(data_full,Candidate, State, lng, lat),vars(cos),funs(mean(.,na.rm=TRUE))))
data_scores$norm_cos=signif(((data_scores$cos)-min(data_scores$cos))/(max(data_scores$cos)-min(data_scores$cos))*100, 2)
#States=as.data.frame(unique(data_scores$State))
lng2=as.data.frame(unique(data_scores$lng))
lat2=as.data.frame(unique(data_scores$lat))
##webapp
ui <-fluidPage(
titlePanel("Debate Reactor"),
sidebarLayout(
sidebarPanel(
helpText("Create maps ranking twitter reaction by state following debates."),
selectInput("candidate",
label = "Choose a candidate to display",
choices = c( "Joe Biden"="Biden",
"Pete Buttigieg"="Buttigieg",
"Amy Klobuchar"="Klobuchar",
"Bernie Sanders"="Sanders",
"Tom Steyer"="Steyer",
"Elizabeth Warren"="Warren",
"Andrew Yang"="Yang"),
selected = "Candidate"),
dateInput("date", label = h3("Date of debate"), value = "2019-12-20")),
hr()),
mainPanel(
textOutput("candidate_selected"),
leafletOutput("map"),
p()
)
)
server <- function(input, output, session) {
output$candidate_selected <- renderText({
paste("Twitter engagement for", input$candidate, "for debate on",
input$date, "Topics include RACISM and GUN VIOLENCE.")
})
output$map <- renderLeaflet({
score <- rank(as.data.frame(subset(data_scores$norm_cos, data_scores$Candidate==input$candidate)))
#score <-rank(as.data.frame(subset(data_scores$norm_cos, data_scores$Candidate=="Biden")))
df<-cbind(score, lng2, lat2)
colnames(df)=c( "score", "lng", "lat")
leaflet(df,width = 400, height = 400 ) %>% addTiles() %>%
addCircles(lng = ~lng, lat = ~lat, weight = 1,
radius = ~score * 30000, popup = paste( "Debate resonated #",data=rank(-(subset(data_scores$norm_cos,
data_scores$Candidate==input$candidate)), ties.method = "last"),
"among 11 swing states" )
)
})
}
shinyApp(ui, server)
